<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <title>Noomman Documentation</title>
    <meta name="description" content="Documentation for Noomman">
    <meta name="author" content="Cody Miro Jones">

    <!-- Mobile Specific Metas
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
  
    <!-- FONT
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link href="https://fonts.googleapis.com/css?family=Nanum+Gothic&display=swap" rel="stylesheet">
  
    <!-- CSS
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link rel="stylesheet" href="./static/normalize.css">
    <link rel="stylesheet" href="./static/skeleton.css">
    <link rel="stylesheet" href="./static/custom.css">
</head>
<body>
    <div class="container">
        <section class="header">
            <h1>Noomman</h1>
            <p><strong>N</strong>odejs <strong>O</strong>bject-<strong>O</strong>riented <strong>M</strong>ongoDB <strong>Man</strong>ager</p>
        </section>
    </div>
    <div class="navbar">
        <div class="container">
            <ul class="navbar-list">
                <li class="navbar-item">
                    <a class="navbar-link" href="./index.html">Introduction</a>
                </li>
                <li class="navbar-item">
                    <a class="navbar-link" href="./gettingstarted.html">Getting Started</a>
                </li>
                <li class="navbar-item">
                    <a class="navbar-link" href="./reference.html">Reference</a>
                </li>
                <li class="navbar-item">
                    <a class="navbar-link" href="./documentation.html">Documentation</a>
                </li>
            </ul>
        </div>
    </div>
    
    <div class="docs-section">
        <div class="container">
            <h3>Reference</h3>

            <p>
                This reference walks through all the features of noomman. If this is your 
                first experience with noomman, I suggest starting with the 
                <a href="./gettingstarted.html">Getting Started</a> guide.
            </p>

            <ul>
                <li>
                    <strong><a href="#concepts">Concepts</a></strong>
                </li>
                <li>
                    <strong><a href="#classModels">Class Models</a></strong>
                    <ul>
                        <li><a href="#classmodel_schema">Class Model Schema</a></li>
                        <li><a href="#attribute_schema">Attributes</a></li>
                        <li><a href="#relationship_schema">Relationships</a></li>
                        <li><a href="#privileges_schema">Privilege Functions</a></li>
                        <li><a href="#validation_schema">Validations</a></li>
                    </ul>
                </li>
                <li>
                    <strong><a href="#instances">Instances</a></strong>
                    <ul>
                        <li><a href="#creating_instances">Creating Instances</a></li>
                        <li><a href="#instance_properties">Instance Properties</a></li>
                        <li><a href="#saving_instances">Saving Instances</a></li>
                        <li><a href="#deleting_instances">Deleting Instances</a></li>
                        <li><a href="#instance_relationships">Instance Relationships</a></li>
                        <li><a href="#miscillaneous_instance_methods">More Helpful Methods</a></li>
                    </ul>
                </li>
                <li>
                    <strong><a href="#instance_sets">Instance Sets</a></strong>
                    <ul>
                        <li><a href="#creating_instance_sets">Creating Instance Sets</a></li>
                        <li><a href="#adding_to_instance_sets">Adding Instances to an Instance Set</a></li>
                        <li><a href="#removing_from_instance_sets">Removing Instances from an Instance Set</a></li>
                        <li><a href="#instance_set_has">Checking For Instances In An Instance Set</a></li>
                        <li><a href="#instance_set_get">retrieving Instances From Instance Sets</a></li>
                        <li><a href="#instance_set_math">Set Math with Instance Sets</a></li>
                        <li><a href="#map_reduce_filter">ForEach, Map, Reduce, and Filter with Instance Sets</a></li>
                        <li><a href="#querying_instance_sets">Querying with Instance Sets</a></li>
                        <li><a href="#saving_instance_sets">Saving Instance Sets</a></li>
                        <li><a href="#deleting_instance_sets">Deleting Instance Sets</a></li>
                    </ul>
                </li>
                <li>
                    <strong><a href="#queries">Queries</a></strong>
                    <ul>
                        <li><a href="#find">Find</a></li>
                        <li><a href="#find_one">Find One</a></li>
                        <li><a href="#find_by_id">Find By Id</a></li>
                    </ul>
                </li>
                <li>
                    <strong><a href="#relationships">Relationships</a></strong>
                    <ul>
                        <li><a href="#setting_relationships">Setting Relationships</a></li>
                        <li><a href="#walking_relationships">Walking Relationships</a></li>
                    </ul>
                </li>
            </ul>

        </div>
    </div>

    <div class="docs-section" id="concepts">
        <div class="container">
            <h4>Noomman Concepts</h4>

            <p>
                Noomman is designed to make it super simple to take a project from a Class Model Diagram
                to a working backend. As such, the terminology and methodology all stems from diagraming concepts.
            </p>

            <h5>Terminology</h5>

            <div class="row">
                <div class="two columns">
                    <strong>Class Model</strong>
                </div>
                <div class="ten columns">
                    What would be called a Class in object-oriented programing (we would call it a class too
                    if that weren't a reserved word in javascript). A Class Model defines the shape of some data,
                    and encapsulates code that works on Instances of that Class Model.
                </div>
            </div>
            <br>

            <div class="row">
                <div class="two columns">
                    <strong>Attributes</strong>
                </div>
                <div class="ten columns">
                    An attribute is a simple-type property that is defined on a Class Model and stored on an
                    Instance. Attributes might be a number, string, date, or boolean, or an array thereof.
                </div>
            </div>
            <br>

            <div class="row">
                <div class="two columns">
                    <strong>Relationships</strong>
                </div>
                <div class="ten columns">
                    Relationships are properties defined on a Class Model and stored on an Instance, which
                    represent a reference to another Instance or set of Instances. If you're familiar with 
                    SQL databases, than you can think of relationships as those properties which hold foreign keys.
                    Noomman uses MongoDB, so relationships actually hold an ObjectId (for singular relationships),
                    or an array of ObjectIds (for non-singular relationships).
                </div>
            </div>
            <br>

            <div class="row">
                <div class="two columns">
                    <strong>Instance</strong>
                </div>
                <div class="ten columns">
                    An Instance is the instantiation of some Class Model. It has the attributes and relationships
                    defined on the Class Model, as well as a database id.
                </div>
            </div>
            <br>

            <div class="row">
                <div class="two columns">
                    <strong>Instance Set</strong>
                </div>
                <div class="ten columns">
                    An Instance Set is a collection of Instances. Sets are often more useful than arrays
                    when dealing with instances, due to the fact that a set will never have duplicates in it, 
                    and the ability to use set math. 
                </div>
            </div>
            <br>

            <div class="row">
                <div class="two columns">
                    <strong>Walking Relationships</strong>
                </div>
                <div class="ten columns">
                    To 'walk' a relationship is to retrieve the Instance or Instances related to some Instance 
                    through that relationship. The mechanics of it are to get the ObjectIds of the related Instances,
                    which are stored in the relationship, and then run a query on the related Class Model to 
                    retrieve those Instances. Noomman abstracts this away from the user, and so you can simply 
                    'walk' your relationships. 
                </div>
            </div>
            <br>
        </div>
    </div>

    <div class="docs-section" id="classModels">
        <div class="container">
            
            <div id="schema">
                <h4><strong>Class Models</strong></h4>
    
                <p>
                    Class Models are the core of noomman. Class Models define the shape of the data you 
                    wish to store, as well as validations, privileges, and methods. 
                </p>
    
                <p>
                    Class Models are created by calling 
                    <a href="./documentation/ClassModel.html#constructor">new ClassModel()</a> 
                    and passing as an argument a schema 
                    object. The shape of the schema object is shown below with the types of each property. Only
                    the className property is required, and in general omitting a property leads to the behavior
                    that property represents being disabled. 
                </p>
                <pre>
                    <code>
    {
        className: String (required),
        superClasses: [ ClassModel ],
        abstract: Boolean,
        useSuperClassCollection: Boolean,
        auditable: Boolean,
        attributes: [
            {
                name: String (required), 
                type: String (required), 
                list: Boolean,
                required: Boolean,
                unique: Boolean,
                sensitive: Boolean,
                mutex: String,
                requiredGroup: String,
            },
        ],
        relationships: [
            {
                name: String (required),
                toClass: String (required),
                singular: Boolean (required),
                required: Boolean,
                owns: Boolean,
                mirrorRelationship: String,
                mutex: String,
                requiredGroup: String,
            }
        ],
        privileges: {
            create: Function,
            read: Function,
            update: Function,
            delete: Function,
            sensitive: Function,
        },
        validations: [ Function ],
        indices: [ fieldOrSpec ], 
        staticMethods: {
            methodName: Function,
            methodName: Function,
            ...
        },
        nonStaticMethods: {
            methodName: Function,
            methodName: Function,
            ...
        },
    }
                    </code>
                </pre>

            </div>
            <br>
    
            <div id='classmodel_schema'>
                <div class="row">
                    <div class = "twelve columns">
                        <h5><strong>Class Model Schema</strong></h5>
                    </div>
                </div>
                <p>The top-level properties of a schema object are the following:</p>
                <div class="row">
                    <div class="three columns">
                        <strong>className</strong>
                    </div>
                    <div class="nine columns">
                        A unique name for a ClassModel. This name is used in the 'toClass' field when defining relationships to this ClassModel.
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>superClasses</strong>
                    </div>
                    <div class="nine columns">
                        An array containing all the ClassModels that this ClassModel directly inherits from.
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>abstract</strong>
                    </div>
                    <div class="nine columns">
                        A boolean which indicates if this ClassModel is abstract. You cannot create Instances of an
                        abstract ClassModel, but you can use an abstract ClassModel as a super class for other 
                        ClassModels.
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>useParentCollection</strong>
                    </div>
                    <div class="nine columns">
                        A boolean which indicates whether this ClassModel stores its instances in the
                        same collection as its super ClassModel. If true, this ClassModel's instances will
                        be stored in the same collection as its super ClassModel, if false or undefined, it will have 
                        its own collection. This can only be set to true if the ClassModel has one and only
                        one super ClassModel. When multiple ClassModels share a collection, the Class Model of an Instance
                        can be distinguised by an extra indexed field in the collection '__t', which will be set to 
                        the className of the Class Model of each Instance.
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>auditable</strong>
                    </div>
                    <div class="nine columns">
                        A boolean which indicates if a change log should be kept of all the updates to each instance of this ClassModel.
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>attributes</strong>
                    </div>
                    <div class="nine columns">
                        An array containing objects which define each attribute. An attribute is simple-type property.
                        It can hold the following data types, or an array thereof: String, Number, Boolean, Date.
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>relationships</strong>
                    </div>
                    <div class="nine columns">
                        An array containing objects which define each relationship from this ClassModel to another 
                        (or to this ClassModel).
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>privileges</strong>
                    </div>
                    <div class="nine columns">
                        An object which can have up to five properties: create, read, update, 
                        delete, and sensitive. Set each of these properties to a function 
                        which will return true if the operation is allowed, and return false otherwise. 
                        If any of these properties is left undefined, it is equivalent to 
                        setting the property to a function which always returns true 
                        (i.e. operation is allowed in all cases).
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>validations</strong>
                    </div>
                    <div class="nine columns">
                        An array of functions which will be executed before any create or update operation 
                        saves an instance to the database. A validation function is expected to throw an 
                        error if the instance is invalid and should not be saved. 
                        Validation functions are executed in the context of a single instance, with 'this' properly set. 
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>indices</strong>
                    </div>
                    <div class="nine columns">
                        An array of names of attributes or relationships that you would like to index in the database. 
                        Indexes can be used to improve query performance when filtering on those properties that have an index.
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>staticMethods</strong>
                    </div>
                    <div class="nine columns">
                        An object used to define user created static methods for this ClassModel. Each property of this object 
                        will be accessible as a method on the ClassModel, with the key acting as the name of the method. 
                    </div>
                </div>
                <br>
    
                <div class="row">
                    <div class="three columns">
                        <strong>nonStaticMethods</strong>
                    </div>
                    <div class="nine columns">
                        An object used to define user created non-static methods for this ClassModel. Each property of this object 
                        will be accessible as a method on instances of this ClassModel, with the key acting as the name of the method. 
                        In non-static methods, user can use the 'this' javascript keyword to access the Instance that the method was
                        called on. 
                    </div>
                </div>
                <br>

            </div>
            <br>


            <div id="attribute_schema">
                <div class="row">
                    <div class = "twelve columns">
                        <h5><strong>Attribute Definitions</strong></h5>
                    </div>
                </div>
                <div class="row">
                    <div class="twelve columns">
                        <p>
                            Attribute definitions are defined in an object nested inside the 'attributes' array. 
                            Attribute defintion objects can have the following properties.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>Property</strong></div>
                    <div class="eight columns"><strong>Description</strong></div>
                    <div class="two columns"><strong>Required</strong></div>
                </div>
                <br>
                <div class="row">
                    <div class="two columns"><strong>name</strong></div>
                    <div class="eight columns">
                        <p>
                            The name for this attribute. 
                            This must be unique among the names of attributes and relationships for this ClassModel.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>Yes</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>type</strong></div>
                    <div class="eight columns">
                        <p>
                            The data type that this attribute will hold.
                            Possible values are String, Number, Boolean, and Date.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>Yes</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>list</strong></div>
                    <div class="eight columns">
                        <p>
                            A boolean which indicates whether this attribute holds a single value or an array of values.
                            If true, the attribute will hold an array of elements of the given type, if false or undefined,
                            the attribute will hold a single element of the given type.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>required</strong></div>
                    <div class="eight columns">
                        <p>
                            A boolean which indicates whether this attribute is required. If an attribute is
                            required, it must be populated on an instance or the instance will throw an error when a save
                            is attempted. Defitions of what is considered populated for each type can be found <a href='#required'>here</a>.
                            If false or undefined, the attribute is not required.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>mutex</strong></div>
                    <div class="eight columns">
                        <p>
                            A string which can be used to create a mutually exclusive group of attributes and relationships. If
                            multiple attibutes and relationship share the same value for mutex, only one of them can be populated
                            at a time. If multipile attributes and/or relationships sharing a mutex are populated, an error will be
                            thrown when attempting to save the instance. If undefined, this attribute is not part of any mutex group.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>requiredGroup</strong></div>
                    <div class="eight columns">
                        <p>
                            A string which can be used to create a group of attibutes and/or relationships, of which at least
                            one is required to be populated. An error will be throw when attempting to save an instance which
                            has none of the attributes and/or relationships in a required group populated. If undefined, this 
                            attribute is not part of any required group.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>unique</strong></div>
                    <div class="eight columns">
                        <p>
                            A boolean indicating whether this attribute must have a unique value among every instance of this
                            ClassModel. If this is set to true, an error will be thrown when attempting to save an instance with
                            this value set to the same value for this attribute in another instance. This funtionallity only applies 
                            to non-list attributes. If undefined or false, this attribute is not required to be unique.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>sensitive</strong></div>
                    <div class="eight columns">
                        <p>
                            A boolean which indicates that this attribute is 'sensitive'. Sensitive attributes will be stripped
                            out when the instance is returned by a query, unless the sensitive function defined in the 
                            privileges object on the schema returns a promise resolving to true. You can use this funtionallity
                            as added protection for sensitive information such as social security numbers and other personally
                            identifiable information. If false or undefined, the attribute is not considered sensitive.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
            </div>
            <br>


            <div id="relationship_schema">
                <div class="row">
                    <div class = "twelve columns">
                        <h5><strong>Relationship Definitions</strong></h5>
                    </div>
                </div>
                <div class="row">
                    <div class="twelve columns">
                        <p>
                            Relationship definitions are defined in an object nested inside the 'relationships' array. 
                            Relationship defintion objects can have the following properties.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>Property</strong></div>
                    <div class="eight columns"><strong>Description</strong></div>
                    <div class="two columns"><strong>Required</strong></div>
                </div>
                <br>
                <div class="row">
                    <div class="two columns"><strong>name</strong></div>
                    <div class="eight columns">
                        <p>
                            The name for this attribute. 
                            This must be unique among the names of attributes and relationships for this ClassModel.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>Yes</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>toClass</strong></div>
                    <div class="eight columns">
                        <p>
                            A string set to the className of the ClassModel this relationship is to. This must match
                            the className of the related class exactly and is case-sensitive.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>Yes</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>singular</strong></div>
                    <div class="eight columns">
                        <p>
                            A boolean indicating whether this relationship is to a single related instance, or to many
                            related instances. Marking this true means that the cardinallity of the relationship is 
                            'to-one', while marking this false means the cardinallity is 'to-many'.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>Yes</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>mirrorRelationship</strong></div>
                    <div class="eight columns">
                        <p>
                            A string which is equal to the name of the reverse/mirror/sibling relationship set on the 
                            related classModel. Use this for defining two-way relationships, and Noomman will keep both
                            relationships in sync for you. If undefined, then this will be treated as a one-way relationship.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>owns</strong></div>
                    <div class="eight columns">
                        <p>
                            A boolean indicating whether an instance of this ClassModel owns the related instance. 
                            If set to true, whenever an instance of this ClassModel is deleted, the instance related
                            to the deleted instance through an owns relationship will also be deleted. If false or
                            undefined, then deleting an instance of this ClassModel will not delete the related
                            instance.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>required</strong></div>
                    <div class="eight columns">
                        <p>
                            A boolean which indicates whether this relationship is required. If an relationship is
                            required, it must be populated on an instance or the instance will throw an error when a save
                            is attempted. If false or undefined, the relationship is not required.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>mutex</strong></div>
                    <div class="eight columns">
                        <p>
                            A string which can be used to create a mutually exclusive group of attributes and relationships. If
                            multiple attibutes and relationship share the same value for mutex, only one of them can be populated
                            at a time. If multipile attributes and/or relationships sharing a mutex are populated, an error will be
                            thrown when attempting to save the instance. If undefined, this relationship is not part of any mutex group.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>requiredGroup</strong></div>
                    <div class="eight columns">
                        <p>
                            A string which can be used to create a group of attibutes and/or relationships, of which at least
                            one is required to be populated. An error will be throw when attempting to save an instance which
                            has none of the attributes and/or relationships in a required group populated. If undefined, this 
                            relationship is not part of any required group.
                        </p>
                    </div>
                    <div class="two columns">
                        <p>No</p>
                    </div>
                </div>
            </div>
            <br>


            <div id="privileges_schema">
                <div class="row">
                    <div class = "twelve columns">
                        <h5><strong>Privileges</strong></h5>
                    </div>
                </div>
                <div class="row">
                    <div class="twelve columns">
                        <p>
                            The privileges object allows you to specify functions which will be called before 
                            attempting a particular operation. The functions can be synchronous or asynchronous, and
                            are called in the context of a particular instance (with 'this' keyword set properly). Each function 
                            should return true if the operation is allowed for a particular instance, or false if the operation
                            should be blocked. There are four properties to set, one for each CRUD operation,
                            and an additional one which is used to determine if sensitive attributes need to be 
                            stripped before being returned from a query.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>create</strong></div>
                    <div class="ten columns">
                        <p>
                            A function which will be called whenever a new instance is saved (i.e.
                            an insert operation). If the function returns false, the instance will not be saved and an error 
                            will be thrown. If the function returns true, the save will be allowed to continue. If not set, 
                            all new instances of this ClassModel can be saved.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>read</strong></div>
                    <div class="ten columns">
                        <p>
                            A function which will be called for every instance returned by a query.
                            Any instance for which this function returns false will not be returned as part
                            of the query, however, other instances for which the function resolves will still be 
                            returned. If not set, any query will return all instances matching the query.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>update</strong></div>
                    <div class="ten columns">
                        <p>
                            A function which will be called whenever an existing instance is saved (i.e.
                            an update operation). If the function returns false, the instance will not be saved, 
                            and an error will be thrown. If the function resolves, the save will be allowed 
                            to continue. If not set, all new instances of this ClassModel can be saved.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>delete</strong></div>
                    <div class="ten columns">
                        <p>
                            A function which will be called whenever an instance is deleted. 
                            If the function returns false, the instance will not be deleted, and an 
                            error will be thrown. If the function resolves, the delete will be 
                            allowed to continue. If not set, all instances of this ClassModel can be deleted.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="two columns"><strong>sensitive</strong></div>
                    <div class="ten columns">
                        <p>
                            A function which will be called for each instance whenever a query
                            is executed. If this function returns false for a given instance, all the attributes
                            marked as sensitive will be stripped from the instance. If this function resolves,
                            the sensitive attributes will not be stripped from the instance. If not set,
                            no attributes ever be stripped from instances.
                        </p>
                    </div>
                </div>
            </div>
            <br>


            <div id="validation_schema">
                <div class="row">
                    <div class = "twelve columns">
                        <h5><strong>Validations</strong></h5>
                    </div>
                </div>
                <div class="row">
                    <div class = "twelve columns">
                        <p>
                            Validations is an array containing functions which will be called before
                            each create and update operation (i.e. everytime save is called). Each funtion will
                            execute in the context of a particular instance (with 'this' set properly). These 
                            functions are expected to return or resolve if an instance is valid, otherwise they 
                            should throw an error with a message indicating why the instance is invalid. 
                            The instance will only be saved if all validations run without throwing an error. 
                        </p>
                    </div>
                </div>
            


            </div>


            <div id="staticAndNonStaticMethods">
                <div class="row">
                    <div class = "twelve columns">
                        <h5><strong>Static and Non-Static Methods</strong></h5>
                    </div>
                </div>
                <div class="row">
                    <div class="twelve columns">
                        <p>
                            The staticMethods and nonStaticMethods properties of the schema object are used to define
                            static and non-static methods that can be called on this Class Model or Instances of this
                            Class Model. The key or property name inside one of these objects represents the name of 
                            the static or non-static method, while the value of the property is the function that will 
                            be called. 
                        </p>
                        <p>
                            Static methods can be called from the Class Model, while non-static methods are called from 
                            an Instance of the Class Model, and are run in the context of the Instance (with 'this' keyword
                            properly set). Static and non-static methods can be synchronous or asynchronous.
                        </p>
                        <p>
                            Below is an example of how you might use static and non-static methods on a User Class Model.
                        </p>
                    </div>
                </div>
                <pre>
                    <code>
const User = new ClassModel({
    className: 'User',
    attributes: [
        {
            name: 'firstName',
            type: String,
        },
        {
            name: 'lastName',
            type: String,
        },
    ],
    staticMethods: {
        getAdults: async function() {
            return User.find({age: {$gte: 18}});
        },
    },
    nonStaticMethods: {
        fullName: function() {
            return this.firstName + ' ' + this.lastName;
        },
    },
});

...

const adults = await User.getAdults();
console.log('Found these adults: ' + adults.map(user => user.fullName());
                    </code>
                </pre>
            </div>
            <br>

        </div>
    </div>

    <div class="docs-section" id="instances">
        <div class="container">
            <div>
                
                <h4><strong>Instances</strong></h4>

                <p>
                    The Instance Class in noomman provides a set of methods for working with your data. When creating
                    an Instance, you provide the Class Model for that Instance, and all aspects of that Class Model 
                    will be enforced for your Instanes. Any query run on a Class Model will return Instances.
                </p>

                <p>
                    Any Instance you create or get from a query will have methods for editing, comparing, saving, and 
                    deleting that Instance. When saving an Instance, all validations and requirements defined on the 
                    Class Model for that Instance will be evaluated before save. 
                </p>

            </div>

            <div id="creating_instances">
                
                <h5><strong>Creating Instances</strong></h5>

                <p>
                    Instances in noomman are created by calling 
                    <a href="documentation/Instance.html#constructor">new Instance()</a> 
                    and passing as an argument the Class
                    Model for that Instance. The next example assumes that a Class Model has been created called User.
                </p>

                <pre>
                    <code>
    const noomman = require('noomman');
    const Instance = noomman.Instance;

    const User = require('./path/to/User');

    const newUser = new Instance(User);
                    </code>
                </pre>

                <p>
                    From here, you can use the assign() method to assign all or some of the attributes
                    and relationships for your instance from an object. Alternatively, you could set
                    the attributes and relationships one at a time.
                </p>

                <pre>
                    <code>
    newUser.assign({
        userName: 'coolUser1',
        email: 'cool@email.com',
        password: '***************',
    });                  
                    </code>
                </pre>

                <strong>OR</strong>

                <pre>
                    <code>
    newUser.userName = 'coolUser1';
    newUser.email = 'cool@email.com';
    newUser.password = '***************';          
                    </code>
                </pre>
            </div>

            <div id="instance_properties">
                
                <h5><strong>Instance Properites</strong></h5>

                <p>
                    All Instances in noomman have share a few properties regardless of Class Model.
                </p>
                
                <strong>The id Property</strong>

                <p>
                    All Instances have an id, which is the mongodb ObjectId of the Instance. You can access this
                    property on an instance using '._id'. For convenience, you can also access this id as a String
                    (rather than an ObjectId object) by using '.id'.
                </p>

                <pre>
                    <code>
const instance = new Instance(SomeClassModel);
const objectId = instance._id; //Returns the id as an ObjectId object.
const idAsString = instance.id; //Returns the id as the hexString representation of the ObjectId object.
                    </code>
                </pre>
                
                <strong>The classModel Property</strong>

                <p>
                    All Instances have a Class Model, which you can access with the classModel property.
                </p>

                <pre>
                    <code>
const instance = new Instance(SomeClassModel);
console.log(instance.classModel === SomeClassModel) // logs true
                    </code>
                </pre>

            </div>

            <div id="saving_instances">
        
                
                <h5><strong>Saving Instances</strong></h5>

                <p>
                    Saving Instances in noomman is as easy as calling 
                    <a href="documentation/Instance.html#save">save()</a>
                    .  Behind the scenes, noomman will 
                    validate the properties on the Instance to make sure they conform to the Class Model schema, and
                    throw an error if they do not. 
                </p>

                <pre>
                    <code>
await newUser.save();
                    </code>
                </pre>

                <p>
                    This 
                    <a href="documentation/Instance.html#save">instance.save()</a>
                    method is an asynchronous function, so you should use await or 
                    use a .then() to wait for the promise to resolve. 
                </p>
                <p>
                    <a href="documentation/Instance.html#save">instance.save()</a> 
                    returns a promise which resolves with the instance that was saved. 
                    It is the exact same object as the instance
                    that you called save on, so you don't necessarily have to use the returned instance if you
                    want to make more changes, you could use the one you already had. i.e. 
                </p>
                
                <pre>
                    <code>
const savedUser = await newUser.save();
// The next statement will print 'true' to the console.
console.log(newUser === savedUser);
                    </code>
                </pre>

                <p>
                    If there is an error, 
                    <a href="documentation/Instance.html#save">instance.save()</a> 
                    will throw the error for your code to handle. A save error
                    may occur due to your custom validations defined on you ClassModel schema, a missing required 
                    attribute or relationship, or a mutex or required group validation. It is up to you to handle these
                    errors. If your code is assuming that your instance should pass all these validations, then you might
                    want to log the error in your application's error log for debugging. If you are taking in potentially 
                    bad input from a user, you might want to catch the error and then have your UI prompt the user for 
                    better input.
                </p>
            </div>

            
            <div id="deleting_instances">
                
                <h5><strong>Deleting Instances</strong></h5>

                <p>
                    Instances can be deleted using the 
                    
                    <a href="documentation/Instance.html#delete">instance.delete()</a> 
                    method. Instances can only be deleted if they
                    are already in the database. Attempting to delete an instance which has never been saved, or which 
                    has already been deleted will throw an error. The delete method is asynchronous and will resolve if
                    the delete is successful.
                </p>

                <pre>
                    <code>
await newUser.delete(); 
                    </code>
                </pre>

            </div>

            <div id="instance_relationships">
                <h5>Handling Relationships on Instances</h5>
            </div>

            <div id="miscillaneous_instance_methods">
                <h5>More Helpful Methods</h5>
            </div>


        </div>
    </div>

    <div class="docs-section" id="instance_sets">
        <div class="container">
                
            <h5><strong>Instance Sets</strong></h5>

            <p>
                Noomman uses the concept of Instance Sets to collect and manipulate multiple instances of 
                the same ClassModel at the same time. This is done using the Noomman class InstanceSet.
                InstanceSet is a sub class of the native JavaScript Set class, with added methods for 
                set mathematics, saving, and walking relationships. InstanceSets have a 'size' property
                which will tell you how many Instances the InstanceSet contains.
            </p>

            <div id="creating_instance_sets">
                
                <h5><strong>Creating Instance Sets</strong></h5>
    
                <p>
                    InstanceSets are created using 
                    <a href="./documentation/InstanceSet.html#constructor">new InstanceSet()</a> 
                    At a minimum, you must supply the 
                    InstanceSet constructor with the ClassModel of the instances it is holding. There is
                    second arguemnt, instances, which you can use if you already have instances you would
                    like to add to the set. The second argument must be an iterable object containing instances.
                    All instances added to an InstanceSet (whether during construction
                    or after construction) must be of the same ClassModel of the InstanceSet, or a sub class
                    thereof. 
                </p>
                <pre>
                    <code>
const users = new InstanceSet(User);
                    </code>
                </pre>
            </div>

            <div id="adding_to_instance_sets">
                
                <h5><strong>Adding Instances to Instance Sets</strong></h5>
    
                <p>
                    There are 3 ways to add instances to an InstanceSet. The first is during construction. 
                    When adding instances using the constructor you must pass in an iterable object 
                    (array, set, or InstanceSet) containing instances.
                </p>
                <pre>
                    <code>
// Adding instances during construction.
const user1 = new Instance(User);
const user2 = new Instance(User);

const users = new InstanceSet(User, [user1, user2]);
                    </code>
                </pre>
                <p>
                    The next way to add instances to an InstanceSet is using the  
                    <a href="./documentation/InstanceSet.html#add">instanceSet.add()</a> 
                    method. When adding instances using the 
                    <a href="./documentation/InstanceSet.html#add">instanceSet.add()</a> 
                    method, you pass in a single instance you would like to add as the only argument to the 
                    method. 
                </p>
                <pre>
                    <code>
// Adding instances using the instanceSet.add() method.
const user1 = new Instance(User);
const user2 = new Instance(User);

const users = new InstanceSet(User);
users.add(user1);
users.add(user2);
                    </code>
                </pre>
                <p>
                    The final way to add Instances to an InstanceSet is to use the instanceSet.addInstances() method.
                    <a href="./documentation/InstanceSet.html#addInstances">instanceSet.addInstances()</a> 
                    method. 
                    When using the 
                    <a href="./documentation/InstanceSet.html#addInstances">instanceSet.addInstances()</a> 
                    method, you must pass in an iterable object (array, set, or InstanceSet) containing instances.
                </p>
                <pre>
                    <code>
// Adding instances using the instanceSet.addInstances() method.
const user1 = new Instance(User);
const user2 = new Instance(User);

const users = new InstanceSet(User);
users.addInstances([user1, user2]);
                    </code>
                </pre>
            </div>

            <p>
                Whatever method you use, an error will be thrown if any instance you try to add is not 
                an instance of the ClassModel or a sub class of the ClassModel of the InstanceSet.
            </p>

            <div id="removing_from_instance_sets">
                
                <h5><strong>Removing Instances from Instance Sets</strong></h5>
    
                <p>
                    Similar to adding instances to a InstanceSet, instances can be removed from an 
                    InstanceSet using the 
                    <a href="./documentation/InstanceSet.html#remove">instanceSet.remove()</a> 
                    and 
                    <a href="./documentation/InstanceSet.html#removeInstances">instanceSet.removeInstances()</a> 
                    methods. 
                    The 
                    <a href="./documentation/InstanceSet.html#remove">instanceSet.remove()</a> 
                    method takes a single instance as an argument and the
                    <a href="./documentation/InstanceSet.html#removeInstances">instanceSet.removeInstances()</a> 
                    method takes an iterable object 
                    (array, set, or InstanceSet) as an argument. The methods determine what Instance to remove
                    from an InstanceSet using the object Ids of the instance, rather than object equallity. 
                    Both methods return true if all given
                    instances have been removed from the set. If you try to remove an instance that is not
                    a part of the set, an error will be thrown. (If you're trying to remove some set of instances
                    that may or may not be in an InstanceSet, see <a href="#instance_set_math">Set Math With Instance Sets</a>).
                </p>
                <pre>
                    <code>
// Removing instance using the instanceSet.remove() method.
users.remove(user1);
                    </code>
                </pre>
                <pre>
                    <code>
// Removing instances using the instanceSet.removeInstances() method.
users.removeInstances([user1, user2]);
                    </code>
                </pre>
            </div>

            <div id="instance_set_has">
                
                <h5><strong>Checking For Instances In An Instance Set</strong></h5>

                <p>
                    You can easily check if an InstanceSet contains a particular Instance in one of two ways.
                </p>

                <p>
                    If you already have the Instance you're looking for in a variable, you can use the 
                    <a href="./documentation/InstanceSet.html#hasInstance">instanceSet.hasInstance()</a> 
                    method. This method takes an Instance as an argument and 
                    returns true if the InstanceSet contains that instance, and returns false otherwise.
                </p>

                <pre>
                    <code>
const user = new Instance(User);
const userSet = new InstanceSet(User, [user]);

console.log(userSet.hasInstance(user)); // true
                    </code>
                </pre>

                <p>
                    If you only have the id of the Instance you are looking for, you can use the 
                    <a href="./documentation/InstanceSet.html#hasInstanceWithId">instanceSet.hasInstanceWithId()</a> 
                    method. This method takes an ObjectId object 
                    or a string as a parameter.
                </p>

                <pre>
                    <code>
const user = new Instance(User);
const userSet = new InstanceSet(User, [user]);

console.log(userSet.hasInstanceWithId(user._id)); // true
console.log(userSet.hasInstanceWithId(user.id)); // true
                    </code>
                </pre>
                
            </div>

            <div id="instance_set_get">
                
                <h5><strong>Retrieving Instances from Instance Sets</strong></h5>

                <p>
                    It is easy to get individual Instances out of an InstanceSet.
                </p>

                <p>
                    If you want to treat the InstanceSet as if it were an array, you can call the 
                    <a href="./documentation/InstanceSet.html#instanceAt">instanceSet.instanceAt()</a> 
                    method. This method takes a single parameter, index, which
                    should be a positive number. The method will create an Array from the InstanceSet and 
                    return to you the Instance at the given index.
                </p>

                <pre>
                    <code>
const user = new Instance(User);
const userSet = new InstanceSet(User, [user]);

const alsoUser = userSet.instanceAt(0);
console.log(alsoUser === user); // true
                    </code>
                </pre>

                <p>
                    If you have the id of the Instance you are looking for, you can use the 
                    <a href="./documentation/InstanceSet.html#getInstanceWithId">instanceSet.getInstanceWithId()</a> 
                    method. This method takes an ObjectId object 
                    or a string as a parameter.
                </p>

                <pre>
                    <code>
const user = new Instance(User);
const userSet = new InstanceSet(User, [user]);

console.log(userSet.getInstanceWithId(user._id) === user); // true
console.log(userSet.getInstanceWithId(user.id) === user); // true
                    </code>
                </pre>
                
            </div>

            <div id="instance_set_math">
                
                <h5><strong>Set Math with Instance Sets</strong></h5>
    
                <p>
                    The InstanceSet class provides non-static methods for set math on InstanceSets. All 
                    of these methods return a new InstanceSet, with the ClassModel of the InstanceSet that 
                    the method was called on. These methods do not update the original InstanceSets.
                </p>
                <p>
                    There are four set math methods, 
                    <a href="./documentation/InstanceSet.html#union">union()</a>, 
                    <a href="./documentation/InstanceSet.html#difference">difference()</a>, 
                    <a href="./documentation/InstanceSet.html#intersection">intersection()</a>, 
                    <a href="./documentation/InstanceSet.html#symmetricDifference">symmetricDifference()</a>.
                    These correspond to the basic set math opperations. For information on
                    set math, see this 
                    <a href="https://en.wikipedia.org/wiki/Set_(mathematics)#Basic_operations">wikipedia page</a>.
                    (Note that another name for difference is relative compliment.)
                </p>
                <pre>
                    <code>
const user1 = new Instance(User);
const user2 = new Instance(User);
const user3 = new Instance(User);

const users1 = new InstanceSet(User, [user1, user2]);
const users2 = new InstanceSet(User, [user2, user3]);

// union is a new InstanceSet containing user1, user2, user3
const union = users1.union(users2);

// difference is a new InstanceSet containing user1
const difference = users1.difference(users2);

// intersection is a new InstanceSet containing user2
const intersection = users1.intersection(users2);

// symmetricDifference is a new InstanceSet containing user1, user3
const symmetricDifference = users1.symmetricDifference(users2);
                    </code>
                </pre>
            </div>



            <div id="map_reduce_filter">
                
                    <h5><strong>ForEach, Map, Reduce, and Filter with Instance Sets</strong></h5>
        
                    <p>
                        InstanceSet has non-static methods for looping, mapping, reducing, and filtering
                        instance sets. These methods each follow the same conventions as the 
                        native javascript methods on the Array class. 
                        <a href="./documentation/InstanceSet.html#map">instanceSet.map()</a> 
                        and 
                        <a href="./documentation/InstanceSet.html#filter">instanceSet.filter()</a> 
                        each return an Array, while reduce returns a single
                        value or object (or an Array if you code it that way). 
                        <a href="./documentation/InstanceSet.html#forEach">instanceSet.forEach()</a> 
                        will iterate through all the instances in an InstanceSet and call your callback
                        for each one, passing the instance as an argument.
                        For general information on these functions, see this 
                        <a href="https://medium.com/poka-techblog/simplify-your-javascript-use-map-reduce-and-filter-bd02c593cc2d">
                            helpful medium post
                        </a>.
                    </p>

                    <p>
                        InstanceSet also has versions of map and filter which return a new InstanceSet
                        instead of an Array. These methods are 
                        <a href="./documentation/InstanceSet.html#mapToInstanceSet">instanceSet.mapToInstanceSet()</a> 
                        and 
                        <a href="./documentation/InstanceSet.html#filterToInstanceSet">instanceSet.filterToInstanceSet()</a>. 
                        They take the same arguments and operate the
                        same as the regular map and filter methods, except that they return an InstanceSet
                        with the same ClassModel as the InstanceSet that the method was called on. 
                    </p>

                    <pre>
                        <code>
const filteredUsers = users.filterToInstanceSet(user => user.userName === "coolUser1");

// The above is the equivalent of the following:
const filteredUsersArray = users.filter(user => user.userName === "coolUser1");
const filteredUsers = new InstanceSet(User, filteredUsersArray);
                        </code>
                    </pre>
                </div>



                <div id="querying_instance_sets">
                    
                        <h5><strong>Querying with Instance Sets (For Future Release)</strong></h5>
            
                        <p>
                            InstanceSet has a non-static query method, which allows you to filter the InstanceSet
                            using MongoDB style filter objects. This does not make a database call, rather it is 
                            just another convenient way to filter an Instance Set. The query method returns 
                            a new InstanceSet with the same ClassModel as the original set and does not update
                            the original InstanceSet. This is implemented using the npm package mingo.
                        </p>
    
                        <pre>
                            <code>
const filteredUsers = Users.filterToInstanceSet(User => User.userName === "coolUser1");

// The above is the equivalent of the following:
const filteredUsers = Users.query({ userName: "coolUser1" });
                            </code>
                        </pre>
                    </div>



                    <div id="saving_instance_sets">
                        
                        <h5><strong>Saving Instance Sets</strong></h5>
            
                        <p>
                            InstanceSet has non-static method 
                            <a href="./documentation/InstanceSet.html#save">instanceSet.save()</a>
                             which will save all the instances in the set.
                            It is smart enough to only save those instances which you have made changes to or 
                            are brand new instances. 
                            It also will run the correct validations for each instance in the Instance Set
                            before saving (including custom validations, required, mutex, and required group 
                            validations and create and update functions).
                            All of the validations run before any instance is saved. If <strong>any</strong>
                            of the instances fail any validation or privilege function, none of the instances 
                            will be saved and an error will be thrown. 
                        </p>
    
                        <pre>
                            <code>
await Users.save();
                            </code>
                        </pre>
                    </div>



                    <div id="deleting_instance_sets">
                        
                        <h5><strong>Deleting Instance Sets</strong></h5>
            
                        <p>
                            InstanceSet has non-static method 
                            <a href="./documentation/InstanceSet.html#delete">instanceSet.delete()</a> 
                            which will delete all of the
                            instances in the InstanceSet. It will run the delete function(s) for 
                            each instance using the instances ClassModel. If an error is thrown for
                            any instance by a delete function, the error will be thrown by the
                            delete method and none of the instances will be deleted. 
                        </p>
    
                        <pre>
                            <code>
await Users.delete();
                            </code>
                        </pre>
                    </div>





        </div>
    </div>

    <div class="docs-section" id="queries">
        <div class="container">
                
            <h5><strong>Queries</strong></h5>

            <p>
                All database queries in Noomman are done through non-static methods on the ClassModel
                of the instances you wish to find. All the query methods take a mongo compliant filter
                object as an argument. Each method is asynchronus and will resolve with the instances found.
            </p>
            <p>
                Queries respect inheritance, so running a query on 
                a ClassModel which is a super class will also query/return instances of all its sub
                ClassModels. If there are multiple levels of inheritance, this will proceed all the way
                down the inheritance tree. If no instances are found matching the query, an empty
                InstanceSet is returned.
            </p>

            <div id="find">
                
                <h5><strong>Find</strong></h5>
    
                <p>
                    The 
                    <a href="./documentation/ClassModel.html#find">find()</a> 
                    method is the most basic query method. It will return an InstanceSet
                    with the same ClassModel as the ClassModel that you called find on. The returned
                    InstanceSet will contain all the instances of the ClassModel (and its sub ClassModels)
                    from the database matching your query. 
                </p>

                <p>
                    Assuming there is a User saved with the 
                    user name 'coolUser1', the following example will return an InstanceSet containing 
                    that instance.
                </p>
                <pre>
                    <code>
const coolUser1InstanceSet = await User.find({ userName: 'coolUser1' });
                    </code>
                </pre>
            </div>

            <div id="find_one">
                
                <h5><strong>Find One</strong></h5>
    
                <p>
                    The 
                    <a href="./documentation/ClassModel.html#findOne">findOne()</a> 
                    method is similar to the find method, except that it will only return a
                    single instance, rather than an InstanceSet. If multiple instances would match
                    your query, only the first one found will be returned (there is no guarantee
                    which instance would be the 'first one found'). If no instance is found matching the 
                    query, null will be returned.
                </p>

                <p>
                    Assuming there is a User saved with the 
                    user name 'coolUser1', the following example will return the User instance
                    for that user name.
                </p>
                <pre>
                    <code>
const coolUser1 = await User.findOne({ userName: 'coolUser1' });
                    </code>
                </pre>
            </div>

            <div id="find_by_id">
                
                <h5><strong>Find By Id</strong></h5>
    
                <p>
                    The 
                    <a href="./documentation/ClassModel.html#findById">findById()</a> 
                    method behaves the same as findOne, except that it accepts an ObjectId as an
                    argument. The object id can either me an ObjectId object or its hex string equivalent.
                    One key difference between findById() and findOne() is that findById() will return null if 
                    you don't pass it an object id, while calling findOne with a query { _id: undefined } will 
                    return the first instance it evaluates. If no instance is found matching a query, null
                    will be returned.
                </p>
                <pre>
                    <code>
const coolUser1 = await User.findOne({ userName: 'coolUser1' });
const coolUser1UsingFindById = await User.findById(coolUser1.id);

console.log(coolUser1.equals(coolUser1UsingFindById)); // true
                    </code>
                </pre>
            </div>



        </div>
    </div>

    

    <div class="docs-section" id="relationships">
        <div class="container">
                
            <h5><strong>Relationships</strong></h5>

            <p>
                Relationships in Noomman abstract away the underlying foriegn key management and
                querying a developer would normally need to worry about when working with a database. 
                Relationships are well defined in ClassModel schema, so Noomman can do the querying
                for you, properly respecting inheritance.
            </p>

            <p>
                For the following examples, we'll be using the User ClassModel we have been 
                working with, along with a new ClassModel called Person, defined below.
            </p>

            <pre>
                <code>
const noomman = require('noomman');
const ClassModel = noomman.ClassModel;



const Person = new ClassModel({
    className: 'Person',
    attributes: [
        {
            name: 'firstName',
            type: String,
            required: true,
        },
        {
            name: 'lastName',
            type: String,
            required: true,
        },
        {
            name: 'dateOfBirth',
            type: Date,
            required: true,
        },
    ],
    relationships: [
        {
            name: 'user',
            toClass: 'User',
            singular: true,
            mirrorRelationship: 'person',
            required: true
        },
        {
            name: 'friends',
            toClass: 'Person',
            singular: false,
            mirrorRelationship: 'friendOf',
        },
        {
            name: 'friendOf',
            toClass: 'Person',
            singular: false,
            mirrorRelationship: 'friends',
        }
    ],
    validations: [
        friendIsNotSelf,
    ]
});

async function friendIsNotSelf() {
    const friends = await this.friends;
    const friendOf = await this.friendOf;

    if (friends.has(this) || friendOf.has(this))
        throw new Error('A Person cannot be a friend to or friend of him or her self.');
}

module.exports = Person;
                </code>
            </pre>

            <p>
                Notice that our new Person ClassModel has a singular relationship to the 
                User for this Person, and a two non-singular relationships to other 
                Persons. The two non-singular relationships are actually the two sides of 
                the same relationship, i.e. a person can have many 'friends', and a person 
                can be the 'friendOf' many persons. We also add a validation function so 
                that a Person cannot be their own friend.
            </p>

            <div id="setting_relationships">
                
                <h5><strong>Setting Relationships</strong></h5>
    
                <p>
                    Setting a relationship on an instance is as easy as setting a property on an object.
                    Singular relationships must be set to an Instance and non-singular relationships must 
                    be set to an InstanceSet. Whether singular or non-singular, the Instance or InstanceSet
                    that you set a relationship to must be of the same ClassModel that set as the 'toClass'
                    in the ClassModel schema (or a sub ClassModel there of). Otherwise an error will be 
                    thrown.
                </p>

                <pre>
                    <code>
const noomman = require('noomman');
const Instance = noomman.Instance;

const User = require('./path/to/User');
const Person = require('./path/to/Person');

async function createAccountForJohnny() {
    const johnny = new Instance(Person);
    johnny.assign({
        firstName: 'Johnny',
        lastName: 'Nanners',
        dateOfBirth: new Date('1984-05-16');
    });
    
    const johnnyAccount = new Instance(User);
    johnnyAccount.assign({
        userName: 'johnny84',
        email: 'johnnynanners@email.com',
        password: 'ih8CT',
    });
    
    johnny.user = johnnyAccount;
    
    await johnny.save();
}

createAccountForJohnny().catch(error => console.error(error.message));
                    </code>
                </pre>

                <p>
                    In the above example, we create two instances: johnny and johnnyAccount. We set the attributes of 
                    each, and then we set the 'user' relationship of johnny (a Person) to johnnyAccount (a 
                    User). Then we save both instances. 
                </p>

                <p>
                    You may be wondering why we did not set the relationship
                    'person' on johnnyAccount (the User) to johnny (the Person). Noomman will do this automatically
                    for us when we call save. It will see that the one Instance is related to the other, and that the
                    other side of the relationship is not set (the mirrorRelationship). You might also wonder why we
                    only call save on johnny. The reasoning is the same, Noomman knows that johnny is related to
                    johnnyAccount, and that johnnyAccount has changes to it (in this case it never existed in the 
                    first place), and so Nooman will implicitly call johnnyAccount.save() as well (only after
                    setting the reverse relationship). This is the magic of Noomman.
                </p>

                <p>
                    Note: If you were to set both sides of the relationship, it would have the same effect. Also 
                    if you were to call save on both instances, it would have the same effect, and your second
                    call to save wouldn't actually insert or update any documents in the database, because Noomman
                    will see that there have been no new changes to those instances since the last save. Below see
                    the same code with the extra relationship set and the second call to save.
                </p>

                <pre>
                    <code>
const noomman = require('noomman');
const Instance = noomman.Instance;

const User = require('./path/to/User');
const Person = require('./path/to/Person');

async function createAccountForJohnny() {
    const johnny = new Instance(Person);
    johnny.assign({
        firstName: 'Johnny',
        lastName: 'Nanners',
        dateOfBirth: new Date('1984-05-16');
    });
    
    const johnnyAccount = new Instance(User);
    johnnyAccount.assign({
        userName: 'johnny84',
        email: 'johnnynanners@email.com',
        password: 'ih8CT',
    });
    
    johnny.user = johnnyAccount;

    // This next line is not necessary, but causes no harm.
    johnnyAccount.person = johnny;
    
    await johnny.save();

    // This next line will not actually 'save' anything, because
    // no changes have been made to the instances since the 
    // last call of save(). It is unnecessary but not harmful.
    await johnnyAccount.save();
}

createAccountForJohnny().catch(error => console.error(error.message));
                    </code>
                </pre>
            </div>



            <div id="walking_relationships">
                
                <h5><strong>Walking Relationships</strong></h5>

                <p>
                    In Noomman, we refer to the act of getting the instances referenced
                    in a relationship as 'walking' the relationship. If the relationship
                    was just set within the same transaction (i.e. the relationship is
                    populated) then Noomman will just return to you that Instance or InstanceSet,
                    without making a call to the database. If however, you just had an instance
                    returned from a query (i.e. relationship is not populated), and you walk a 
                    relationship from it, then Noomman will do a query for those instances from
                    the database, set the relationship to the returned Instance or InstanceSet
                    (populate the relationship), and then return the Instance or InstanceSet to you.
                    For this reason, walking relationships is always asynchronous, even if a relationship
                    is already populated.
                </p>

                <p>
                    In this example, we create an instance from scratch, set the relationship, and 
                    then walk the relationship. In this case no query is executed because the relationship
                    is already populated, though we do have to use await on it anyway.
                </p>

                <pre>
                    <code>
const noomman = require('noomman');
const Instance = noomman.Instance;

const User = require('./path/to/User');
const Person = require('./path/to/Person');

async function testWalkingRelationship() {
    const johnny = new Instance(Person);
    johnny.assign({
        firstName: 'Johnny',
        lastName: 'Nanners',
        dateOfBirth: new Date('1984-05-16');
    });
    
    const johnnyAccount = new Instance(User);
    johnnyAccount.assign({
        userName: 'johnny84',
        email: 'johnnynanners@email.com',
        password: 'ih8CT',
    });
    
    johnny.user = johnnyAccount;

    // Here we walk the relationship. Because we just 
    // set the relationship, no query is executed. 
    const shouldBeJohnnyAccount = await johnny.user;

    // Next statement prints 'true' to the console.
    console.log(johnnyAccount.equals(shouldBeJohnnyAccount));
}

testWalkingRelationship().catch(error => console.error(error.message));
                    </code>
                </pre>

                <p>
                    In the next example, we assume johnny and johnnyAccount have been saved to the
                    database already. In this case, walking the relationship does execute a query.
                </p>

                <pre>
                    <code>
const johnnyAccount = await User.findOne({
    userName: 'johnny84',
});

// Here we walk the relationship. Because we just retrieved
// johnnyAccount from the database using a query, the 'person' 
// relationship is not populated yet, so a query must be executed
// by Noomman.
const johnny = await johnnyAccount.person;

const alsoJohnny = Person.findOne({
    firstName: 'Johnny',
    lastName: 'Nanners',
    dateOfBirth: new Date('1984-05-16'),
});

// This next line will print 'true' to the console.
console.log(johnny.equals(alsoJohnny));


// If we walk the relationship a second time, no query
// is executed, because the relationship was populated
// the first time we walked the relationship.
johnnyOneMoreTime = await johnnyAccount.person;

// This next line will print 'true' to the console. Note 
// we can use a === here because the exact same instance object
// is returned as when we first walked the relationship.
console.log(johnny === johnnyOneMoreTime);
                    </code>
                </pre>

            </div>
        

        </div>
    </div>
</body>

</html>